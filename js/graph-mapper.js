import { InstrumentType } from './instrument.js';

export class GraphMapper {
    
    /**
     * Builds a static node and edge map from the current Portfolio configuration.
     * @param {Portfolio} portfolio 
     * @returns {Object} { nodes: Array, edges: Array }
     */
    static buildGraph(portfolio) {
        const nodes = [];
        const edges = [];

        // 1. Define the Global Sink Nodes (The Drains)
        // We create explicit nodes for taxes so we can route the "little outflows" to them.
        const sinks = [
            { id: 'Sink_FICA', label: 'FICA / Medicare', category: 'TaxDrain' },
            { id: 'Sink_IncomeTax', label: 'Income Tax', category: 'TaxDrain' },
            { id: 'Sink_CapGainsTax', label: 'Capital Gains Tax', category: 'TaxDrain' },
            { id: 'Sink_PropertyTax', label: 'Property Tax', category: 'TaxDrain' }
        ];
        nodes.push(...sinks);

        nodes.push({ id: 'Global_Wealth', label: 'Growth Lake', category: 'WealthLake' });

        // 2. Iterate Model Assets to build Nodes and Implicit Edges
        for (const asset of portfolio.modelAssets) {
            
            // Determine the visual category based on InstrumentType
            let category = 'Unknown';
            if (InstrumentType.isMonthlyIncome(asset.instrument)) {
                category = 'IncomeLake';
                
                // Implicit Edge: Income generates FICA and Income Tax withholding
                if (!InstrumentType.isSocialSecurity(asset.instrument)) {
                    edges.push({ source: asset.displayName, target: 'Sink_FICA', type: 'Tax' });
                }
                edges.push({ source: asset.displayName, target: 'Sink_IncomeTax', type: 'Tax' });

            } else if (InstrumentType.isMonthlyExpense(asset.instrument)) {
                category = 'ExpenseDrain';
            } else if (InstrumentType.isMortgage(asset.instrument)) {
                category = 'DebtDrain';
            } else if (InstrumentType.isHome(asset.instrument)) {
                category = 'IlliquidAsset';
                // Implicit Edge: Homes generate Property Tax
                edges.push({ source: asset.displayName, target: 'Sink_PropertyTax', type: 'Tax' });
            } else if (InstrumentType.isExpensable(asset.instrument)) {
                category = 'CheckingHub';
            } else if (InstrumentType.isTaxDeferred(asset.instrument)) { // 401K, IRA
                category = 'TaxDeferredReservoir';
                // Implicit Edge: Distributions trigger ordinary income tax
                edges.push({ source: asset.displayName, target: 'Sink_IncomeTax', type: 'Tax' });
            } else if (InstrumentType.isTaxFree(asset.instrument)) { // Roth
                category = 'TaxFreeReservoir';
            } else if (InstrumentType.isTaxableAccount(asset.instrument) || InstrumentType.isCapital(asset.instrument)) {
                category = 'TaxableReservoir';
                // Implicit Edge: Selling triggers capital gains tax
                edges.push({ source: asset.displayName, target: 'Sink_CapGainsTax', type: 'Tax' });
            }

            // Add the Asset Node
            nodes.push({
                id: asset.displayName,
                label: asset.displayName,
                category: category
            });

            // 3. Extract Explicit Edges (Fund Transfers)
            if (asset.fundTransfers && asset.fundTransfers.length > 0) {
                for (const ft of asset.fundTransfers) {
                    edges.push({
                        source: asset.displayName,
                        target: ft.toDisplayName,
                        type: ft.moveOnFinishDate ? 'ClosureTransfer' : 'MonthlyTransfer',
                        weight: ft.moveValue // The percentage or amount
                    });
                }
            }
        }

        return { nodes, edges };
    }


    /**
     * Attaches monthly flow amounts to the structural edges by parsing CreditMemos.
     * @param {Portfolio} portfolio 
     * @param {DateInt} currentDateInt 
     * @param {Array} edges - The edges array generated by buildGraph()
     * @returns {Array} The edges array with `.flowAmount` populated
     */
    static calculateFlows(portfolio, currentDateInt, edges) {
        
        // 1. Reset all flows to 0 for the new month
        for (const edge of edges) {
            edge.flowAmount = 0;
        }

        // 2. Helper to find and add flow to a specific edge
        const addFlow = (sourceId, targetId, amount) => {
            const edge = edges.find(e => e.source === sourceId && e.target === targetId);
            if (edge) {
                edge.flowAmount += Math.abs(amount);
            }
        };

        // 3. Scan the CreditMemos for the current month
        for (const asset of portfolio.modelAssets) {
            
            // Filter memos for exactly this month
            const currentMemos = asset.creditMemos.filter(
                memo => memo.dateInt && memo.dateInt.toInt() === currentDateInt.toInt()
            );

            for (const memo of currentMemos) {
                const amount = memo.amount.amount;
                if (amount === 0) continue;

                // Map Tax and Drain Memos to our Sink Nodes
                if (memo.note === 'FICA withholding') {
                    addFlow(asset.displayName, 'Sink_FICA', amount);
                } 
                else if (memo.note === 'Income tax withholding') {
                    addFlow(asset.displayName, 'Sink_IncomeTax', amount);
                } 
                else if (memo.note === 'Capital gains tax withholding') {
                    addFlow(asset.displayName, 'Sink_CapGainsTax', amount);
                } 
                else if (memo.note === 'Property taxes') {
                    addFlow(asset.displayName, 'Sink_PropertyTax', amount);
                } 
                // Map Explicit Fund Transfers
                // fund-transfer.js writes notes like: "Source → Target (monthly) 10% => $500"
                else if (memo.note.includes('→')) {
                    
                    // We only want to process the debit side of the transfer so we don't double count
                    if (amount < 0) {
                        // Extract the Target name from the note string
                        const match = memo.note.match(/→\s+(.*?)\s+\(/);
                        if (match && match[1]) {
                            const targetName = match[1].trim();
                            addFlow(asset.displayName, targetName, amount);
                        }
                    }
                }
            }
        }

        return edges;
    }

}